{
    parserClass="info.kwarc.mmt.intellij.language.MMTParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="MMT"
    psiImplClassSuffix="_impl"
    psiPackage="info.kwarc.mmt.intellij.language.psi"
    psiImplPackage="info.kwarc.mmt.intellij.language.psi.imps"

    elementTypeHolderClass="info.kwarc.mmt.intellij.language.psi.MMTParserTypes"
    elementTypeClass="info.kwarc.mmt.intellij.language.psi.MMTElementType"
    tokenTypeClass="info.kwarc.mmt.intellij.language.psi.MMTTokenType"
}

file ::= mod*

mod ::= namespace | import | fixmeta | modrule | modcomment | theory | view | diagram

/* Document-level things (i.e. theories, views, diagrams etc.)
   ================================================ */
modcomment ::= COMMENT_KEY (any|OD|DD)* (MD | error)
namespace ::= NAMESPACE_KEY uri (MD | error)
import ::= IMPORT_KEY pname uri (MD | error)
modrule ::= RULE_KEY uri tmlist? (MD | error)
fixmeta ::= FIXMETA_KEY uri (MD|error)

theory ::=  theoryheader ((ABBREV_KEY term) | (EQ_KEY theory_body) | error) (MD | error) { mixin="info.kwarc.mmt.intellij.language.TheoryElement_impl" }
theoryheader ::= THEORY_KEY ((pname (COLON_KEY uri)? (PARAM_KEY tmlist OD)?) | error)
theory_body ::= declaration*

view ::= viewheader ((ABBREV_KEY term) | (EQ_KEY view_body)| error) (MD | error)
viewheader ::= IMPLICIT_KEY? VIEW_KEY ((pname COLON_KEY ((uri ARROW_KEY (uri | error)) | error)) | error)
view_body ::= view_decl*

// Possibly generalize this to derived module declarations
// However, then we cannot catch the error in `diagram blub = PUSHOUT ...`
// where instead of a `:=` we wrongly used `=`.
diagram ::= DIAGRAM_KEY pname (COLON_KEY uri)? COLONEQ_KEY (any|OD|DD)* (MD | error)

/* Module-level things (i.e. declarations)
   ================================================ */
declaration ::= rule | include | decl_comment | nestedtheory | structure | nestedview | constant | deriveddecl
view_decl ::= include | decl_comment | view_constant

nestedtheory ::= theoryheader ((ABBREV_KEY ((term DD) | error)) | (EQ_KEY theory_body (MD | error))) { mixin="info.kwarc.mmt.intellij.language.TheoryElement_impl" }
nestedview ::= viewheader ((ABBREV_KEY term DD) | (EQ_KEY view_body MD))
rule ::= RULE_KEY uri tmlist? (DD | error)

// includes may be defined (both in a theory and a view)
include ::= INCLUDE_KEY (urilit|uri) tmlist? (OD EQ_KEY (urilit|uri))? (DD | error)
decl_comment ::= COMMENT_KEY (any|OD)* (DD|error)

constant ::= CONSTANT_KEY? pname (component OD)* component? DD
view_constant ::= CONSTANT_KEY? pname ((def_comp (DD|error)) | error)

structure ::= IMPLICIT_KEY? STRUCTURE_KEY pname COLON_KEY ((uri ((ABBREV_KEY term (DD|error)) | (EQ_KEY structure_body (MD|error)))) | error)
structure_body ::= (decl_comment | constant | structure | morphism_include)*

deriveddecl ::= (derivedheader theory_body (MD|error)) | (derivedsimple DD)
derivedheader ::= any any+ OD? EQ_KEY
derivedsimple ::= any any+

/* Declaration-level things (i.e. URIs, terms, notations, role annotations etc.)
   ============================================================================== */
component ::= obj_comment | type_comp | def_comp | not_comp | role_comp | meta_comp | alias_comp

obj_comment ::= COMMENT_KEY any*
type_comp ::= COLON_KEY term
def_comp ::= EQ_KEY term
not_comp ::= NOT_KEY any+ prec?
prec ::= PREC_KEY TOKEN
role_comp ::= ROLE_KEY any+
meta_comp ::= (META_KEY | LINK_KEY ) term
alias_comp ::= ALIAS_KEY pname

urilit ::= URI_KEY uri

uri ::= (uritoken COLON_KEY uritoken) | uritoken {
    mixin="info.kwarc.mmt.intellij.language.URIElement_impl"
}
uritoken ::= TOKEN | keywrd
pname ::= TOKEN | keywrd
any ::= TOKEN | keywrd | COLON_KEY | COLONEQ_KEY | COMMENT_KEY | EQ_KEY | NOT_KEY | ALIAS_KEY | PARAM_KEY | ARROW_KEY | COMMA_KEY

tmlist ::= (term COMMA_KEY)* term
term ::= (urilit|any)+

keywrd ::= COMMENT_KEY | NAMESPACE_KEY | IMPORT_KEY | ABBREV_KEY | THEORY_KEY  | VIEW_KEY | DIAGRAM_KEY | RULE_KEY | INCLUDE_KEY | PREC_KEY | ROLE_KEY | META_KEY | CONSTANT_KEY | IMPLICIT_KEY | STRUCTURE_KEY | FIXMETA_KEY | URI_KEY

// vvv This rule is needed even though IntelliJ marks it as unused
//     It forces the "WHITESPACE" token to be created, which is then used by the Lexer
//     generated from mmt.flex
ws ::= WHITESPACE

error ::= any*
